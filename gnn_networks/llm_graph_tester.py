"""
This script is designed for the qualitative and quantitative evaluation of a trained Graph Neural Network (GNN)
on graphs generated by a Large Language Model (LLM). The primary objective is to assess the model's ability
to predict meaningful edges in graphs where only the nodes (representing semantically related topics)
are provided. This serves as a real-world application test for the GNN, evaluating its capacity to
understand and reconstruct semantic relationships.

The script's core functionalities are organized as follows:

1.  **Data Loading and Model Initialization**:
    - It loads a pre-trained GNN model from a specified path.
    - It loads graph data that has been generated by an LLM, consisting of nodes and their
      features but no edges.

2.  **Agnostic AUC (A-AUC) Evaluation**:
    - The `__get_a_auc` function computes the Agnostic AUC, which measures how well the GNN's
      predicted edge probabilities correlate with the semantic similarity of the nodes (as determined
      by cosine similarity of their features). This provides a quantitative measure of the model's
      semantic understanding.

3.  **Graph Reconstruction and Analysis**:
    - The `__build_graph` function reconstructs a graph by predicting edges. It uses the GNN to
      generate an adjacency matrix of edge probabilities and then adds edges to the graph based
      on a predefined probability threshold.
    - The script then analyzes the properties of this reconstructed graph, such as the number of
      edges, average node degree, and connectivity. This offers a qualitative assessment of the
      plausibility of the predicted graph structure.

4.  **Comprehensive Evaluation Workflow**:
    - The `evaluate_llm_graph` function orchestrates the entire evaluation process for a single
      LLM-generated graph. It computes the A-AUC and then reconstructs and analyzes the graph.
    - Wrapper functions (`evaluate_domain_graph` and `evaluate_non_domain_graph`) are provided
      to run this evaluation across a range of different edge probability thresholds, allowing for
      a more thorough analysis of the model's behavior.

5.  **Visualization**:
    - The script includes a function to plot the reconstructed graph, providing a visual representation
      of the GNN's predictions and facilitating a more intuitive understanding of the results.

This evaluation framework is crucial for validating the practical utility of the trained GNN, demonstrating
its ability to generalize to new, unseen data and to perform a task that closely mimics a real-world
use case of knowledge graph completion.
"""

from matplotlib import pyplot as plt
from sklearn.metrics import roc_auc_score
import torch
import sys
import logging
import os
from torch_geometric.data import Data
import networkx as nx
from gnn_model_v1.gat_net_module_v1 import GatModelV1 

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from custom_logger.logger_config import get_logger

log: logging.Logger = get_logger(name=__name__)

# Paths to the pre-trained model and the LLM-generated graph datasets.
MODEL_PATH = "/home/bruno/Documents/GitHub/social-media-nlp/gnn_networks/model_dumps/gat_model_v1_ReLU_LayerNorm_128_64_4x2_d_0.75_315_final_2_20250202-134024.pth"
LLM_GRAPH_DOMAIN = "/home/bruno/Documents/GitHub/social-media-nlp/llm_dataset/only_node_datasets/llm_gen_graph_domain-related_100_20250202-125314.pt"
LLM_GRAPH_NON_DOMAIN = "/home/bruno/Documents/GitHub/social-media-nlp/llm_dataset/only_node_datasets/llm_gen_graph_no-domain-related_100_20250202-124046.pt"

# Thresholds for evaluation.
COSIN_SIM_THRESHOLD = 0.7
EDGE_PROB_THRESHOLD = 0.95

# List of edge probability thresholds to be tested.
EDGE_PR_TRESH_LIST: list[float] = [0.5, 0.6, 0.7, 0.8, 0.9]

def __get_avg_degree(graph: nx.Graph) -> float:
    """Computes the average degree of a NetworkX graph."""
    return sum(dict(graph.degree()).values()) / graph.number_of_nodes()

def __load_datset(torch_grap_path: str) -> tuple[Data, dict[int, str]]:
    """
    Loads a PyTorch Geometric graph dataset from a file.

    Args:
        torch_grap_path (str): The path to the saved tensor file.

    Returns:
        tuple[Data, dict[int, str]]: A tuple containing the graph data and a mapping from node indices to labels.
    """
    grap_dict = torch.load(torch_grap_path)
    data: Data = grap_dict["data"]
    nodes_idx_map: dict[int, str] = grap_dict["nodes_idx_map"]
    
    log.info(f"Loaded tensor graph from {torch_grap_path} with {data.num_nodes} nodes")
    return (data, nodes_idx_map)

@torch.no_grad()
def __get_a_auc(
    model: torch.nn.Module, 
    data: Data, 
    cos_sim_thresh: float = COSIN_SIM_THRESHOLD
) -> float:
    """
    Computes the Agnostic AUC (A-AUC) for a given graph, using the full node set.

    Args:
        model (torch.nn.Module): The trained GNN model.
        data (Data): The graph data.
        cos_sim_thresh (float, optional): The cosine similarity threshold. Defaults to COSIN_SIM_THRESHOLD.

    Returns:
        float: The computed A-AUC score.
    """
    
    model.eval() 
    
    normalized_features = torch.nn.functional.normalize(data.x, p=2, dim=1)
    cos_similarity_matrix = torch.matmul(normalized_features, normalized_features.transpose(0, 1))
    
    treshold_matrix = torch.zeros_like(cos_similarity_matrix)
    treshold_matrix[cos_similarity_matrix > cos_sim_thresh] = 1
    
    z = model.encode(data.x, data.edge_index)
    pred_adj_matrix: torch.Tensor = model.get_adj_prob_matrix(z)

    pred_labels = pred_adj_matrix.flatten()
    fake_true_labels = treshold_matrix.flatten()

    auc = roc_auc_score(fake_true_labels.cpu().numpy(), pred_labels.cpu().numpy())

    return auc

def __build_graph(
    model: torch.nn.Module, 
    data: Data,
    nodes_idx: dict[int, str],
    edge_prob_tresh: float = EDGE_PROB_THRESHOLD
) -> nx.Graph:
    """
    Reconstructs a graph by predicting edges with probabilities above a given threshold.

    Args:
        model (torch.nn.Module): The trained GNN model.
        data (Data): The graph data.
        nodes_idx (dict[int, str]): A mapping from node indices to labels.
        edge_prob_tresh (float, optional): The probability threshold for adding an edge. Defaults to EDGE_PROB_THRESHOLD.

    Returns:
        nx.Graph: The reconstructed NetworkX graph.
    """
    
    graph = nx.Graph()
    for node_label in nodes_idx.values():
        graph.add_node(node_label)

    model.eval() 
    z = model.encode(data.x, data.edge_index)
    prob_adj_matrix: torch.Tensor = model.get_adj_prob_matrix(z)
    
    row_index, col_index = torch.where(prob_adj_matrix > edge_prob_tresh)
    
    for i in range(row_index.size(0)):
        row, col = row_index[i].item(), col_index[i].item()
        
        if not graph.has_edge(nodes_idx[row], nodes_idx[col]) and row != col:
            graph.add_edge(nodes_idx[row], nodes_idx[col])
    
    log.info(f"Built graph with {graph.number_of_nodes()} nodes and {graph.number_of_edges()} edges using prob threshold {edge_prob_tresh}")
    return graph

def __plot_graph(graph: nx.Graph, title: str) -> None:
    """Plots a NetworkX graph for visualization."""
    plt.figure(figsize=(15, 15))
    nx.draw(graph, with_labels=True, node_size=30, font_size=10, font_color="red", node_color="skyblue", edge_color="gray")
    plt.title(title)
    plt.show()

def evaluate_llm_graph(
    llm_graph_path: str, 
    domain_related_info: str, 
    cos_sim_thresh: float = COSIN_SIM_THRESHOLD, 
    prob_thresh: float = EDGE_PROB_THRESHOLD,
    show_graph: bool = False
) -> None:
    """
    Evaluates a GNN model on an LLM-generated graph.

    Args:
        llm_graph_path (str): The path to the LLM-generated graph.
        domain_related_info (str): A string indicating if the graph is domain-related.
        cos_sim_thresh (float, optional): The cosine similarity threshold for A-AUC. Defaults to COSIN_SIM_THRESHOLD.
        prob_thresh (float, optional): The edge probability threshold for graph reconstruction. Defaults to EDGE_PROB_THRESHOLD.
        show_graph (bool, optional): Whether to plot the reconstructed graph. Defaults to False.
    """
    data, nodes_idx = __load_datset(llm_graph_path)
    
    model = torch.load(MODEL_PATH)
    a_auc = __get_a_auc(model=model, data=data, cos_sim_thresh=cos_sim_thresh)
    log.info(f"LLM {domain_related_info} graph, A-AUC({cos_sim_thresh})={a_auc}")
    
    pred_graph = __build_graph(model=model, data=data, nodes_idx=nodes_idx, edge_prob_tresh=prob_thresh)
    avg_degree = __get_avg_degree(pred_graph)
    log.info(f"LLM Reconstructed {domain_related_info} graph (edge_prob_thres={prob_thresh:.4f}) of {pred_graph.number_of_nodes()} nodes, {pred_graph.number_of_edges()} edges, avg-degree {avg_degree:.4f} and connected {nx.is_connected(pred_graph)}")
    
    if show_graph:
        title = f"Predicted graph with edge prob {prob_thresh}\nModel: {model.get_name()}\n{domain_related_info}"
        __plot_graph(pred_graph, title=title)

def evaluate_domain_graph(cos_sim_thres: float = COSIN_SIM_THRESHOLD, prob_to_test: list[float] = EDGE_PR_TRESH_LIST):
    """Evaluates the domain-related LLM graph at multiple probability thresholds."""
    for edge_prob in prob_to_test:
        log.info(f"Evaluating LLM domain graph with edge prob {edge_prob:.4f}")
        evaluate_llm_graph(LLM_GRAPH_DOMAIN, "domain-related", cos_sim_thres, edge_prob, False)

def evaluate_non_domain_graph(cos_sim_thres: float = COSIN_SIM_THRESHOLD, prob_to_test: list[float] = EDGE_PR_TRESH_LIST):
    """Evaluates the non-domain-related LLM graph at multiple probability thresholds."""
    for edge_prob in prob_to_test:
        log.info(f"Evaluating LLM non-domain graph with edge prob {edge_prob:.4f}")
        evaluate_llm_graph(LLM_GRAPH_NON_DOMAIN, "non-domain-related", cos_sim_thres, edge_prob, False)

if __name__ == "__main__":
    # This block serves as the main entry point for the evaluation.
    # It can be configured to evaluate either the domain-related or non-domain-related graph,
    # and to optionally display the reconstructed graph.
    evaluate_llm_graph(
        llm_graph_path=LLM_GRAPH_NON_DOMAIN, 
        domain_related_info="non-domain-related", 
        cos_sim_thresh=COSIN_SIM_THRESHOLD, 
        prob_thresh=EDGE_PROB_THRESHOLD,
        show_graph=True
    )
